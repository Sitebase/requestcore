<?xml version="1.0" encoding="UTF-8"?>
<vanity xmlns="http://github.com/skyzyx/vanity"><class><name>RequestCore</name><fileData><docBlock><section><headline>File</headline><contents><![CDATA[Handles all linear and parallel HTTP requests using cURL and manages the responses.]]></contents></section><section><headline>Version</headline><contents><line><![CDATA[2010.03.21]]></line></contents></section><section><headline>Copyright</headline><contents><line><![CDATA[2006-2010 Ryan Parman, Foleeo Inc., and contributors.]]></line></contents></section><section><headline>License</headline><contents><entry><param><![CDATA[Simplified BSD License]]></param><description><![CDATA[http://opensource.org/licenses/bsd-license.php]]></description></entry></contents></section></docBlock></fileData><summary><file>requestcore.class.php</file><docBlock><section><headline>Class</headline><contents><line><![CDATA[Container for all request-related methods.]]></line></contents></section></docBlock></summary><constants count="5"><constant><name><![CDATA[HTTP_DELETE]]></name><value type="string">DELETE</value></constant><constant><name><![CDATA[HTTP_GET]]></name><value type="string">GET</value></constant><constant><name><![CDATA[HTTP_HEAD]]></name><value type="string">HEAD</value></constant><constant><name><![CDATA[HTTP_POST]]></name><value type="string">POST</value></constant><constant><name><![CDATA[HTTP_PUT]]></name><value type="string">PUT</value></constant></constants><properties count="17"><property><name>curl_handle</name><access>public</access><documented>true</documented><description><line><![CDATA[The handle for the cURL object.]]></line></description></property><property><name>curlopts</name><access>public</access><documented>true</documented><description><line><![CDATA[Custom CURLOPT settings.]]></line></description></property><property><name>method</name><access>public</access><documented>true</documented><description><line><![CDATA[The method by which the request is being made.]]></line></description></property><property><name>password</name><access>public</access><documented>true</documented><description><line><![CDATA[The password to use for the request.]]></line></description></property><property><name>proxy</name><access>public</access><documented>true</documented><description><line><![CDATA[Stores the proxy settings to use for the request.]]></line></description></property><property><name>request_body</name><access>public</access><documented>true</documented><description><line><![CDATA[The body being sent in the request.]]></line></description></property><property><name>request_class</name><defaultValue type="string"><![CDATA[]]></defaultValue><access>public</access><documented>true</documented><description><line><![CDATA[The default class to use for HTTP Requests (defaults to <RequestCore>).]]></line></description></property><property><name>request_headers</name><access>public</access><documented>true</documented><description><line><![CDATA[The headers being sent in the request.]]></line></description></property><property><name>request_url</name><access>public</access><documented>true</documented><description><line><![CDATA[The URL being requested.]]></line></description></property><property><name>response</name><access>public</access><documented>true</documented><description><line><![CDATA[The response returned by the request.]]></line></description></property><property><name>response_body</name><access>public</access><documented>true</documented><description><line><![CDATA[The body returned by the request.]]></line></description></property><property><name>response_class</name><defaultValue type="string"><![CDATA[]]></defaultValue><access>public</access><documented>true</documented><description><line><![CDATA[The default class to use for HTTP Responses (defaults to <ResponseCore>).]]></line></description></property><property><name>response_code</name><access>public</access><documented>true</documented><description><line><![CDATA[The HTTP status code returned by the request.]]></line></description></property><property><name>response_headers</name><access>public</access><documented>true</documented><description><line><![CDATA[The headers returned by the request.]]></line></description></property><property><name>response_info</name><access>public</access><documented>true</documented><description><line><![CDATA[Additional response data.]]></line></description></property><property><name>useragent</name><defaultValue type="string"><![CDATA[]]></defaultValue><access>public</access><documented>true</documented><description><line><![CDATA[Default useragent string to use.]]></line></description></property><property><name>username</name><access>public</access><documented>true</documented><description><line><![CDATA[The username to use for the request.]]></line></description></property></properties><methods count="17"><method><name>__construct</name><parameters><parameter><name>url</name><required>false</required><defaultValue><![CDATA[null]]></defaultValue></parameter><parameter><name>proxy</name><required>false</required><defaultValue><![CDATA[null]]></defaultValue></parameter><parameter><name>helpers</name><required>false</required><defaultValue><![CDATA[null]]></defaultValue></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[The constructor]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$url]]></param><type><![CDATA[string]]></type><required><![CDATA[Optional]]></required><description><![CDATA[The URL to request or service endpoint to query.]]></description></entry><entry><param><![CDATA[$proxy]]></param><type><![CDATA[string]]></type><required><![CDATA[Optional]]></required><description><![CDATA[The faux-url to use for proxy settings. Takes the following format: `proxy://user:pass@hostname:port`]]></description></entry><entry><param><![CDATA[$helpers]]></param><type><![CDATA[array]]></type><required><![CDATA[Optional]]></required><description><![CDATA[An associative array of classnames to use for request, and response functionality. Gets passed in automatically by the calling class.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[`$this`]]></line></contents></section></docBlock><documented>true</documented><source><startLine>187</startLine><endLine>213</endLine><code><![CDATA[	public function __construct($url = null, $proxy = null, $helpers = null)
	{
		// Set some default values.
		$this->request_url = $url;
		$this->method = $this::HTTP_GET;
		$this->request_headers = array();
		$this->request_body = '';

		// Set a new Request class if one was set.
		if (isset($helpers['request']) && !empty($helpers['request']))
		{
			$this->request_class = $helpers['request'];
		}

		// Set a new Request class if one was set.
		if (isset($helpers['response']) && !empty($helpers['response']))
		{
			$this->response_class = $helpers['response'];
		}

		if ($proxy)
		{
			$this->set_proxy($proxy);
		}

		return $this;
	}
]]></code></source></method><method><name>add_header</name><parameters><parameter><name>key</name><required>true</required></parameter><parameter><name>value</name><required>true</required></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Adds a custom HTTP header to the cURL request.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$key]]></param><type><![CDATA[string]]></type><required><![CDATA[Required]]></required><description><![CDATA[The custom HTTP header to set.]]></description></entry><entry><param><![CDATA[$value]]></param><type><![CDATA[mixed]]></type><required><![CDATA[Required]]></required><description><![CDATA[The value to assign to the custom HTTP header.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[`$this`]]></line></contents></section></docBlock><documented>true</documented><source><startLine>254</startLine><endLine>258</endLine><code><![CDATA[	public function add_header($key, $value)
	{
		$this->request_headers[$key] = $value;
		return $this;
	}
]]></code></source></method><method><name>get_response_body</name><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Get the HTTP response body from the request.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Returns</headline><contents><line><![CDATA[_string_ The response body.]]></line></contents></section></docBlock><documented>true</documented><source><startLine>698</startLine><endLine>701</endLine><code><![CDATA[	public function get_response_body()
	{
		return $this->response_body;
	}
]]></code></source></method><method><name>get_response_code</name><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Get the HTTP response code from the request.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Returns</headline><contents><line><![CDATA[_string_ The HTTP response code.]]></line></contents></section></docBlock><documented>true</documented><source><startLine>713</startLine><endLine>716</endLine><code><![CDATA[	public function get_response_code()
	{
		return $this->response_code;
	}
]]></code></source></method><method><name>get_response_header</name><parameters><parameter><name>header</name><required>false</required><defaultValue><![CDATA[null]]></defaultValue></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Get the HTTP response headers from the request.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$header]]></param><type><![CDATA[string]]></type><required><![CDATA[Optional]]></required><description><![CDATA[A specific header value to return. Defaults to all headers.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[_string_|_array_ All or selected header values.]]></line></contents></section></docBlock><documented>true</documented><source><startLine>679</startLine><endLine>686</endLine><code><![CDATA[	public function get_response_header($header = null)
	{
		if ($header)
		{
			return $this->response_headers[strtolower($header)];
		}
		return $this->response_headers;
	}
]]></code></source></method><method><name>prep_request</name><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Prepares and adds the details of the cURL request. This can be passed along to a `curl_multi_exec()` function.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Returns</headline><contents><line><![CDATA[The handle for the cURL object.]]></line></contents></section></docBlock><documented>true</documented><source><startLine>414</startLine><endLine>512</endLine><code><![CDATA[	public function prep_request()
	{
		$this->add_header('Expect', '100-continue');
		$this->add_header('Connection', 'close');

		$curl_handle = curl_init();

		// Set default options.
		curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);
		curl_setopt($curl_handle, CURLOPT_FILETIME, true);
		curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);
		curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);
		curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, true);
		curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);
		curl_setopt($curl_handle, CURLOPT_FOLLOWLOCATION, true);
		curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);
		curl_setopt($curl_handle, CURLOPT_HEADER, true);
		curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);
		curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);
		curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);
		curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);
		curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);
		curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);

		// Merge in the CURLOPTs
		if (isset($this->curlopts) && sizeof($this->curlopts) > 0)
		{
			foreach ($this->curlopts as $k => $v)
			{
				curl_setopt($curl_handle, $k, $v);
			}
		}

		// Enable a proxy connection if requested.
		if ($this->proxy)
		{
			curl_setopt($curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);

			$host = $this->proxy['host'];
			$host .= ($this->proxy['port']) ? ':' . $this->proxy['port'] : '';
			curl_setopt($curl_handle, CURLOPT_PROXY, $host);

			if (isset($this->proxy['user']) && isset($this->proxy['pass']))
			{
				curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);
			}
		}

		// Set credentials for HTTP Basic/Digest Authentication.
		if ($this->username && $this->password)
		{
			curl_setopt($curl_handle, CURLOPT_HTTPAUTH, CURLAUTH_ANY);
			curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);
		}

		// Handle the encoding if we can.
		if (extension_loaded('zlib'))
		{
			curl_setopt($curl_handle, CURLOPT_ENCODING, '');
		}

		// Process custom headers
		if (isset($this->request_headers) && count($this->request_headers))
		{
			$temp_headers = array();

			foreach ($this->request_headers as $k => $v)
			{
				$temp_headers[] = $k . ': ' . $v;
			}

			curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $temp_headers);
		}

		switch ($this->method)
		{
			case $this::HTTP_PUT:
				curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');
				curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);
				break;

			case $this::HTTP_POST:
				curl_setopt($curl_handle, CURLOPT_POST, true);
				curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);
				break;

			case $this::HTTP_HEAD:
				curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this::HTTP_HEAD);
				curl_setopt($curl_handle, CURLOPT_NOBODY, 1);
				break;

			default:
				curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);
				curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);
				break;
		}

		return $curl_handle;
	}
]]></code></source></method><method><name>process_response</name><parameters><parameter><name>curl_handle</name><required>false</required><defaultValue><![CDATA[null]]></defaultValue></parameter><parameter><name>response</name><required>false</required><defaultValue><![CDATA[null]]></defaultValue></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Take the post-processed cURL data and break it down into useful header/body/info chunks. Uses the data stored in the <curl_handle> and <response> properties unless replacement data is passed in via parameters.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$curl_handle]]></param><type><![CDATA[string]]></type><required><![CDATA[Optional]]></required><description><![CDATA[The reference to the already executed cURL request.]]></description></entry><entry><param><![CDATA[$response]]></param><type><![CDATA[string]]></type><required><![CDATA[Optional]]></required><description><![CDATA[The actual response content itself that needs to be parsed.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[<ResponseCore> object]]></line></contents></section></docBlock><documented>true</documented><source><startLine>528</startLine><endLine>574</endLine><code><![CDATA[	public function process_response($curl_handle = null, $response = null)
	{
		// Accept a custom one if it's passed.
		if ($curl_handle && $response)
		{
			$this->curl_handle = $curl_handle;
			$this->response = $response;
		}

		// As long as this came back as a valid resource...
		if (is_resource($this->curl_handle))
		{
			// Determine what's what.
			$header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);
			$this->response_headers = substr($this->response, 0, $header_size);
			$this->response_body = substr($this->response, $header_size);
			$this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);
			$this->response_info = curl_getinfo($this->curl_handle);

			// Parse out the headers
			$this->response_headers = explode("\r\n\r\n", trim($this->response_headers));
			$this->response_headers = array_pop($this->response_headers);
			$this->response_headers = explode("\r\n", $this->response_headers);
			array_shift($this->response_headers);

			// Loop through and split up the headers.
			$header_assoc = array();
			foreach ($this->response_headers as $header)
			{
				$kv = explode(': ', $header);
				$header_assoc[strtolower($kv[0])] = $kv[1];
			}

			// Reset the headers to the appropriate property.
			$this->response_headers = $header_assoc;
			$this->response_headers['_info'] = $this->response_info;
			$this->response_headers['_info']['method'] = $this->method;

			if ($curl_handle && $response)
			{
				return new $this->response_class($this->response_headers, $this->response_body, $this->response_code);
			}
		}

		// Return false
		return false;
	}
]]></code></source></method><method><name>remove_header</name><parameters><parameter><name>key</name><required>true</required></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Removes an HTTP header from the cURL request.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$key]]></param><type><![CDATA[string]]></type><required><![CDATA[Required]]></required><description><![CDATA[The custom HTTP header to set.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[`$this`]]></line></contents></section></docBlock><documented>true</documented><source><startLine>273</startLine><endLine>280</endLine><code><![CDATA[	public function remove_header($key)
	{
		if (isset($this->request_headers[$key]))
		{
			unset($this->request_headers[$key]);
		}
		return $this;
	}
]]></code></source></method><method><name>send_multi_request</name><parameters><parameter><name>handles</name><required>true</required></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Sends the request using curl_multi_exec(), enabling parallel requests.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$handles]]></param><type><![CDATA[array]]></type><required><![CDATA[Required]]></required><description><![CDATA[An indexed array of cURL handles to process simultaneously.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[_array_ Post-processed cURL responses.]]></line></contents></section></docBlock><documented>true</documented><source><startLine>618</startLine><endLine>660</endLine><code><![CDATA[	public function send_multi_request($handles)
	{
		// Initialize MultiCURL
		$multi_handle = curl_multi_init();

		// Loop through each of the CURL handles and add them to the MultiCURL request.
		foreach ($handles as $handle)
		{
			curl_multi_add_handle($multi_handle, $handle);
		}

		$count = 0;

		// Execute
		do
		{
			$status = curl_multi_exec($multi_handle, $active);
		}
		while ($status == CURLM_CALL_MULTI_PERFORM || $active);

		// Define this.
		$handles_post = array();

		// Retrieve each handle response
		foreach ($handles as $handle)
		{
			if (curl_errno($handle) == CURLE_OK)
			{
				$http = new $this->request_class(null);
				$handles_post[] = $http->process_response($handle, curl_multi_getcontent($handle));
			}
			else
			{
				throw new RequestCore_Exception(curl_error($handle));
			}

			// Explicitly close each cURL handle.
			curl_multi_remove_handle($multi_handle, $handle);
			curl_close($handle);
		}

		return $handles_post;
	}
]]></code></source></method><method><name>send_request</name><parameters><parameter><name>parse</name><required>false</required><defaultValue><![CDATA[false]]></defaultValue></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Sends the request, calling necessary utility functions to update built-in properties.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$parse]]></param><type><![CDATA[boolean]]></type><required><![CDATA[Optional]]></required><description><![CDATA[Whether to parse the response with ResponseCore or not.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[_string_ The resulting unparsed data from the request.]]></line></contents></section></docBlock><documented>true</documented><source><startLine>589</startLine><endLine>603</endLine><code><![CDATA[	public function send_request($parse = false)
	{
		$curl_handle = $this->prep_request();
		$this->response = curl_exec($curl_handle);
		$parsed_response = $this->process_response($curl_handle, $this->response);

		curl_close($curl_handle);

		if ($parse)
		{
			return $parsed_response;
		}

		return $this->response;
	}
]]></code></source></method><method><name>set_body</name><parameters><parameter><name>body</name><required>true</required></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Set the body to send in the request.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$body]]></param><type><![CDATA[string]]></type><required><![CDATA[Required]]></required><description><![CDATA[The textual content to send along in the body of the request.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[`$this`]]></line></contents></section></docBlock><documented>true</documented><source><startLine>333</startLine><endLine>337</endLine><code><![CDATA[	public function set_body($body)
	{
		$this->request_body = $body;
		return $this;
	}
]]></code></source></method><method><name>set_credentials</name><parameters><parameter><name>user</name><required>true</required></parameter><parameter><name>pass</name><required>true</required></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Sets the credentials to use for authentication.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$user]]></param><type><![CDATA[string]]></type><required><![CDATA[Required]]></required><description><![CDATA[The username to authenticate with.]]></description></entry><entry><param><![CDATA[$pass]]></param><type><![CDATA[string]]></type><required><![CDATA[Required]]></required><description><![CDATA[The password to authenticate with.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[`$this`]]></line></contents></section></docBlock><documented>true</documented><source><startLine>233</startLine><endLine>238</endLine><code><![CDATA[	public function set_credentials($user, $pass)
	{
		$this->username = $user;
		$this->password = $pass;
		return $this;
	}
]]></code></source></method><method><name>set_curlopts</name><parameters><parameter><name>curlopts</name><required>true</required></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Set additional CURLOPT settings. These will merge with the default settings, and override if there is a duplicate.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$curlopts]]></param><type><![CDATA[array]]></type><required><![CDATA[Optional]]></required><description><![CDATA[A set of key-value pairs that set `CURLOPT` options. These will merge with the existing CURLOPTs, and ones passed here will override the defaults. Keys should be the `CURLOPT_` constants, not strings.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[`$this`]]></line></contents></section></docBlock><documented>true</documented><source><startLine>371</startLine><endLine>375</endLine><code><![CDATA[	public function set_curlopts($curlopts)
	{
		$this->curlopts = $curlopts;
		return $this;
	}
]]></code></source></method><method><name>set_method</name><parameters><parameter><name>method</name><required>true</required></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Set the method type for the request.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$method]]></param><type><![CDATA[string]]></type><required><![CDATA[Required]]></required><description><![CDATA[One of the following constants: <HTTP_GET>, <HTTP_POST>, <HTTP_PUT>, <HTTP_HEAD>, <HTTP_DELETE>.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[`$this`]]></line></contents></section></docBlock><documented>true</documented><source><startLine>295</startLine><endLine>299</endLine><code><![CDATA[	public function set_method($method)
	{
		$this->method = strtoupper($method);
		return $this;
	}
]]></code></source></method><method><name>set_proxy</name><parameters><parameter><name>proxy</name><required>true</required></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Set the proxy to use for making requests.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$proxy]]></param><type><![CDATA[string]]></type><required><![CDATA[Optional]]></required><description><![CDATA[The faux-url to use for proxy settings. Takes the following format: `proxy://user:pass@hostname:port`]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[`$this`]]></line></contents></section></docBlock><documented>true</documented><source><startLine>390</startLine><endLine>398</endLine><code><![CDATA[	public function set_proxy($proxy)
	{
		$proxy = parse_url($proxy);
		$proxy['user'] = isset($proxy['user']) ? $proxy['user'] : null;
		$proxy['pass'] = isset($proxy['pass']) ? $proxy['pass'] : null;
		$proxy['port'] = isset($proxy['port']) ? $proxy['port'] : null;
		$this->proxy = $proxy;
		return $this;
	}
]]></code></source></method><method><name>set_request_url</name><parameters><parameter><name>url</name><required>true</required></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Set the URL to make the request to.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$url]]></param><type><![CDATA[string]]></type><required><![CDATA[Required]]></required><description><![CDATA[The URL to make the request to.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[`$this`]]></line></contents></section></docBlock><documented>true</documented><source><startLine>352</startLine><endLine>356</endLine><code><![CDATA[	public function set_request_url($url)
	{
		$this->request_url = $url;
		return $this;
	}
]]></code></source></method><method><name>set_useragent</name><parameters><parameter><name>ua</name><required>true</required></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Sets a custom useragent string for the class.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$ua]]></param><type><![CDATA[string]]></type><required><![CDATA[Required]]></required><description><![CDATA[The useragent string to use.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[`$this`]]></line></contents></section></docBlock><documented>true</documented><source><startLine>314</startLine><endLine>318</endLine><code><![CDATA[	public function set_useragent($ua)
	{
		$this->useragent = $ua;
		return $this;
	}
]]></code></source></method></methods></class></vanity>
