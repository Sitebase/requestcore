<?xml version="1.0" encoding="UTF-8"?>
<vanity xmlns="http://github.com/skyzyx/vanity"><class><name>RequestCore</name><fileData><docBlock><section><headline>File</headline><contents><![CDATA[Handles all linear and parallel HTTP requests using cURL and manages the responses.]]></contents></section><section><headline>Version</headline><contents><line><![CDATA[2010.03.21]]></line></contents></section><section><headline>Copyright</headline><contents><line><![CDATA[2006-2010 Ryan Parman, Foleeo Inc., and contributors.]]></line></contents></section><section><headline>License</headline><contents><entry><param><![CDATA[Simplified BSD License]]></param><description><![CDATA[http://opensource.org/licenses/bsd-license.php]]></description></entry></contents></section></docBlock></fileData><summary><file>requestcore.class.php</file><docBlock><section><headline>Class</headline><contents><line><![CDATA[Container for all request-related methods.]]></line></contents></section></docBlock></summary><constants count="5"><constant><name><![CDATA[HTTP_DELETE]]></name><value type="string">DELETE</value></constant><constant><name><![CDATA[HTTP_GET]]></name><value type="string">GET</value></constant><constant><name><![CDATA[HTTP_HEAD]]></name><value type="string">HEAD</value></constant><constant><name><![CDATA[HTTP_POST]]></name><value type="string">POST</value></constant><constant><name><![CDATA[HTTP_PUT]]></name><value type="string">PUT</value></constant></constants><properties count="17"><property><name>curl_handle</name><access>public</access><documented>true</documented><description><line><![CDATA[The handle for the cURL object.]]></line></description></property><property><name>curlopts</name><access>public</access><documented>true</documented><description><line><![CDATA[Custom CURLOPT settings.]]></line></description></property><property><name>method</name><access>public</access><documented>true</documented><description><line><![CDATA[The method by which the request is being made.]]></line></description></property><property><name>password</name><access>public</access><documented>true</documented><description><line><![CDATA[The password to use for the request.]]></line></description></property><property><name>proxy</name><access>public</access><documented>true</documented><description><line><![CDATA[Stores the proxy settings to use for the request.]]></line></description></property><property><name>request_body</name><access>public</access><documented>true</documented><description><line><![CDATA[The body being sent in the request.]]></line></description></property><property><name>request_class</name><defaultValue type="string"><![CDATA[]]></defaultValue><access>public</access><documented>true</documented><description><line><![CDATA[The default class to use for HTTP Requests (defaults to [RequestCore](../requestcore/index.html)).]]></line></description></property><property><name>request_headers</name><access>public</access><documented>true</documented><description><line><![CDATA[The headers being sent in the request.]]></line></description></property><property><name>request_url</name><access>public</access><documented>true</documented><description><line><![CDATA[The URL being requested.]]></line></description></property><property><name>response</name><access>public</access><documented>true</documented><description><line><![CDATA[The response returned by the request.]]></line></description></property><property><name>response_body</name><access>public</access><documented>true</documented><description><line><![CDATA[The body returned by the request.]]></line></description></property><property><name>response_class</name><defaultValue type="string"><![CDATA[]]></defaultValue><access>public</access><documented>true</documented><description><line><![CDATA[The default class to use for HTTP Responses (defaults to [ResponseCore](../responsecore/index.html)).]]></line></description></property><property><name>response_code</name><access>public</access><documented>true</documented><description><line><![CDATA[The HTTP status code returned by the request.]]></line></description></property><property><name>response_headers</name><access>public</access><documented>true</documented><description><line><![CDATA[The headers returned by the request.]]></line></description></property><property><name>response_info</name><access>public</access><documented>true</documented><description><line><![CDATA[Additional response data.]]></line></description></property><property><name>useragent</name><defaultValue type="string"><![CDATA[]]></defaultValue><access>public</access><documented>true</documented><description><line><![CDATA[Default useragent string to use.]]></line></description></property><property><name>username</name><access>public</access><documented>true</documented><description><line><![CDATA[The username to use for the request.]]></line></description></property></properties><methods count="17"><method><name>__construct</name><parameters><parameter><name>url</name><required>false</required><defaultValue><![CDATA[null]]></defaultValue></parameter><parameter><name>proxy</name><required>false</required><defaultValue><![CDATA[null]]></defaultValue></parameter><parameter><name>helpers</name><required>false</required><defaultValue><![CDATA[null]]></defaultValue></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[The constructor]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$url]]></param><type><![CDATA[string]]></type><required><![CDATA[Optional]]></required><description><![CDATA[The URL to request or service endpoint to query.]]></description></entry><entry><param><![CDATA[$proxy]]></param><type><![CDATA[string]]></type><required><![CDATA[Optional]]></required><description><![CDATA[The faux-url to use for proxy settings. Takes the following format: `proxy://user:pass@hostname:port`]]></description></entry><entry><param><![CDATA[$helpers]]></param><type><![CDATA[array]]></type><required><![CDATA[Optional]]></required><description><![CDATA[An associative array of classnames to use for request, and response functionality. Gets passed in automatically by the calling class.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[`$this`]]></line></contents></section></docBlock><documented>true</documented><source><startLine>187</startLine><endLine>213</endLine><numberOfLines>27</numberOfLines><code><![CDATA[public function __construct($url = null, $proxy = null, $helpers = null)
{
    // Set some default values.
    $this-&gt;request_url = $url;
    $this-&gt;method = $this::HTTP_GET;
    $this-&gt;request_headers = array();
    $this-&gt;request_body = '';

    // Set a new Request class if one was set.
    if (isset($helpers['request']) &amp;&amp; !empty($helpers['request']))
    {
        $this-&gt;request_class = $helpers['request'];
    }

    // Set a new Request class if one was set.
    if (isset($helpers['response']) &amp;&amp; !empty($helpers['response']))
    {
        $this-&gt;response_class = $helpers['response'];
    }

    if ($proxy)
    {
        $this-&gt;set_proxy($proxy);
    }

    return $this;
}
]]></code></source></method><method><name>add_header</name><parameters><parameter><name>key</name><required>true</required></parameter><parameter><name>value</name><required>true</required></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Adds a custom HTTP header to the cURL request.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$key]]></param><type><![CDATA[string]]></type><required><![CDATA[Required]]></required><description><![CDATA[The custom HTTP header to set.]]></description></entry><entry><param><![CDATA[$value]]></param><type><![CDATA[mixed]]></type><required><![CDATA[Required]]></required><description><![CDATA[The value to assign to the custom HTTP header.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[`$this`]]></line></contents></section></docBlock><documented>true</documented><source><startLine>254</startLine><endLine>258</endLine><numberOfLines>5</numberOfLines><code><![CDATA[public function add_header($key, $value)
{
    $this-&gt;request_headers[$key] = $value;
    return $this;
}
]]></code></source><examples><example><title><![CDATA[Add a custom header to the request (without firing it).]]></title><code><![CDATA[$http = new RequestCore('http://github.com/skyzyx/requestcore/raw/master/_tests/test_request.txt');
$http-&gt;prep_request();
$http-&gt;add_header('x-requestcore-header', 'value');

var_dump($http-&gt;request_headers);]]></code><result><![CDATA[array(3) {
  ["Expect"]=&gt;
  string(12) "100-continue"
  ["Connection"]=&gt;
  string(5) "close"
  ["x-requestcore-header"]=&gt;
  string(5) "value"
}]]></result></example></examples></method><method><name>get_response_body</name><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Get the HTTP response body from the request.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Returns</headline><contents><line><![CDATA[_string_ The response body.]]></line></contents></section></docBlock><documented>true</documented><source><startLine>698</startLine><endLine>701</endLine><numberOfLines>4</numberOfLines><code><![CDATA[public function get_response_body()
{
    return $this-&gt;response_body;
}
]]></code></source><examples><example><title><![CDATA[Display the response body of the request.]]></title><code><![CDATA[$http = new RequestCore('http://github.com/skyzyx/requestcore/raw/master/_tests/test_request.txt');
$http-&gt;send_request();

var_dump($http-&gt;get_response_body());]]></code><result><![CDATA[string(48) "abcdefghijklmnopqrstuvwxyz
0123456789
!@#$%^&amp;*()"]]></result></example></examples></method><method><name>get_response_code</name><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Get the HTTP response code from the request.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Returns</headline><contents><line><![CDATA[_string_ The HTTP response code.]]></line></contents></section></docBlock><documented>true</documented><source><startLine>713</startLine><endLine>716</endLine><numberOfLines>4</numberOfLines><code><![CDATA[public function get_response_code()
{
    return $this-&gt;response_code;
}
]]></code></source><examples><example><title><![CDATA[Display the response code for the request.]]></title><code><![CDATA[$http = new RequestCore('http://github.com/skyzyx/requestcore/raw/master/_tests/test_request.txt');
$http-&gt;send_request();

var_dump($http-&gt;get_response_code());]]></code><result><![CDATA[int(200)]]></result></example></examples></method><method><name>get_response_header</name><parameters><parameter><name>header</name><required>false</required><defaultValue><![CDATA[null]]></defaultValue></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Get the HTTP response headers from the request.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$header]]></param><type><![CDATA[string]]></type><required><![CDATA[Optional]]></required><description><![CDATA[A specific header value to return. Defaults to all headers.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[_string_|_array_ All or selected header values.]]></line></contents></section></docBlock><documented>true</documented><source><startLine>679</startLine><endLine>686</endLine><numberOfLines>8</numberOfLines><code><![CDATA[public function get_response_header($header = null)
{
    if ($header)
    {
        return $this-&gt;response_headers[strtolower($header)];
    }
    return $this-&gt;response_headers;
}
]]></code></source><examples><example><title><![CDATA[Display the Content-Type header of the response.]]></title><code><![CDATA[$http = new RequestCore('http://github.com/skyzyx/requestcore/raw/master/_tests/test_request.txt');
$http-&gt;send_request();

var_dump($http-&gt;get_response_header('content-type'));]]></code><result><![CDATA[string(25) "text/plain; charset=utf-8"]]></result></example><example><title><![CDATA[Display the URL that was requested.]]></title><code><![CDATA[$http = new RequestCore('http://github.com/skyzyx/requestcore/raw/master/_tests/test_request.txt');
$http-&gt;send_request();
$info = $http-&gt;get_response_header('_info');

var_dump($info['url']);]]></code><result><![CDATA[string(71) "http://github.com/skyzyx/requestcore/raw/master/_tests/test_request.txt"]]></result></example></examples></method><method><name>prep_request</name><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Prepares and adds the details of the cURL request. This can be passed along to a `curl_multi_exec()` function.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Returns</headline><contents><line><![CDATA[The handle for the cURL object.]]></line></contents></section></docBlock><documented>true</documented><source><startLine>414</startLine><endLine>512</endLine><numberOfLines>99</numberOfLines><code><![CDATA[public function prep_request()
{
    $this-&gt;add_header('Expect', '100-continue');
    $this-&gt;add_header('Connection', 'close');

    $curl_handle = curl_init();

    // Set default options.
    curl_setopt($curl_handle, CURLOPT_URL, $this-&gt;request_url);
    curl_setopt($curl_handle, CURLOPT_FILETIME, true);
    curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);
    curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);
    curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, true);
    curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);
    curl_setopt($curl_handle, CURLOPT_FOLLOWLOCATION, true);
    curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);
    curl_setopt($curl_handle, CURLOPT_HEADER, true);
    curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);
    curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);
    curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);
    curl_setopt($curl_handle, CURLOPT_REFERER, $this-&gt;request_url);
    curl_setopt($curl_handle, CURLOPT_USERAGENT, $this-&gt;useragent);

    // Merge in the CURLOPTs
    if (isset($this-&gt;curlopts) &amp;&amp; sizeof($this-&gt;curlopts) &gt; 0)
    {
        foreach ($this-&gt;curlopts as $k =&gt; $v)
        {
            curl_setopt($curl_handle, $k, $v);
        }
    }

    // Enable a proxy connection if requested.
    if ($this-&gt;proxy)
    {
        curl_setopt($curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);

        $host = $this-&gt;proxy['host'];
        $host .= ($this-&gt;proxy['port']) ? ':' . $this-&gt;proxy['port'] : '';
        curl_setopt($curl_handle, CURLOPT_PROXY, $host);

        if (isset($this-&gt;proxy['user']) &amp;&amp; isset($this-&gt;proxy['pass']))
        {
            curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this-&gt;proxy['user'] . ':' . $this-&gt;proxy['pass']);
        }
    }

    // Set credentials for HTTP Basic/Digest Authentication.
    if ($this-&gt;username &amp;&amp; $this-&gt;password)
    {
        curl_setopt($curl_handle, CURLOPT_HTTPAUTH, CURLAUTH_ANY);
        curl_setopt($curl_handle, CURLOPT_USERPWD, $this-&gt;username . ':' . $this-&gt;password);
    }

    // Handle the encoding if we can.
    if (extension_loaded('zlib'))
    {
        curl_setopt($curl_handle, CURLOPT_ENCODING, '');
    }

    // Process custom headers
    if (isset($this-&gt;request_headers) &amp;&amp; count($this-&gt;request_headers))
    {
        $temp_headers = array();

        foreach ($this-&gt;request_headers as $k =&gt; $v)
        {
            $temp_headers[] = $k . ': ' . $v;
        }

        curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $temp_headers);
    }

    switch ($this-&gt;method)
    {
        case $this::HTTP_PUT:
            curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');
            curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this-&gt;request_body);
            break;

        case $this::HTTP_POST:
            curl_setopt($curl_handle, CURLOPT_POST, true);
            curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this-&gt;request_body);
            break;

        case $this::HTTP_HEAD:
            curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this::HTTP_HEAD);
            curl_setopt($curl_handle, CURLOPT_NOBODY, 1);
            break;

        default:
            curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this-&gt;method);
            curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this-&gt;request_body);
            break;
    }

    return $curl_handle;
}
]]></code></source></method><method><name>process_response</name><parameters><parameter><name>curl_handle</name><required>false</required><defaultValue><![CDATA[null]]></defaultValue></parameter><parameter><name>response</name><required>false</required><defaultValue><![CDATA[null]]></defaultValue></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Take the post-processed cURL data and break it down into useful header/body/info chunks. Uses the data stored in the [curl_handle](../requestcore/properties.html#curl_handle) and [response](../requestcore/properties.html#response) properties unless replacement data is passed in via parameters.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$curl_handle]]></param><type><![CDATA[string]]></type><required><![CDATA[Optional]]></required><description><![CDATA[The reference to the already executed cURL request.]]></description></entry><entry><param><![CDATA[$response]]></param><type><![CDATA[string]]></type><required><![CDATA[Optional]]></required><description><![CDATA[The actual response content itself that needs to be parsed.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[[ResponseCore](../responsecore/index.html) object]]></line></contents></section></docBlock><documented>true</documented><source><startLine>528</startLine><endLine>574</endLine><numberOfLines>47</numberOfLines><code><![CDATA[public function process_response($curl_handle = null, $response = null)
{
    // Accept a custom one if it's passed.
    if ($curl_handle &amp;&amp; $response)
    {
        $this-&gt;curl_handle = $curl_handle;
        $this-&gt;response = $response;
    }

    // As long as this came back as a valid resource...
    if (is_resource($this-&gt;curl_handle))
    {
        // Determine what's what.
        $header_size = curl_getinfo($this-&gt;curl_handle, CURLINFO_HEADER_SIZE);
        $this-&gt;response_headers = substr($this-&gt;response, 0, $header_size);
        $this-&gt;response_body = substr($this-&gt;response, $header_size);
        $this-&gt;response_code = curl_getinfo($this-&gt;curl_handle, CURLINFO_HTTP_CODE);
        $this-&gt;response_info = curl_getinfo($this-&gt;curl_handle);

        // Parse out the headers
        $this-&gt;response_headers = explode(&quot;\r\n\r\n&quot;, trim($this-&gt;response_headers));
        $this-&gt;response_headers = array_pop($this-&gt;response_headers);
        $this-&gt;response_headers = explode(&quot;\r\n&quot;, $this-&gt;response_headers);
        array_shift($this-&gt;response_headers);

        // Loop through and split up the headers.
        $header_assoc = array();
        foreach ($this-&gt;response_headers as $header)
        {
            $kv = explode(': ', $header);
            $header_assoc[strtolower($kv[0])] = $kv[1];
        }

        // Reset the headers to the appropriate property.
        $this-&gt;response_headers = $header_assoc;
        $this-&gt;response_headers['_info'] = $this-&gt;response_info;
        $this-&gt;response_headers['_info']['method'] = $this-&gt;method;

        if ($curl_handle &amp;&amp; $response)
        {
            return new $this-&gt;response_class($this-&gt;response_headers, $this-&gt;response_body, $this-&gt;response_code);
        }
    }

    // Return false
    return false;
}
]]></code></source></method><method><name>remove_header</name><parameters><parameter><name>key</name><required>true</required></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Removes an HTTP header from the cURL request.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$key]]></param><type><![CDATA[string]]></type><required><![CDATA[Required]]></required><description><![CDATA[The custom HTTP header to set.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[`$this`]]></line></contents></section></docBlock><documented>true</documented><source><startLine>273</startLine><endLine>280</endLine><numberOfLines>8</numberOfLines><code><![CDATA[public function remove_header($key)
{
    if (isset($this-&gt;request_headers[$key]))
    {
        unset($this-&gt;request_headers[$key]);
    }
    return $this;
}
]]></code></source><examples><example><title><![CDATA[Add a custom header to the request, then remove it (without firing it).]]></title><code><![CDATA[$http = new RequestCore('http://github.com/skyzyx/requestcore/raw/master/_tests/test_request.txt');
$http-&gt;prep_request();

$http-&gt;add_header('x-requestcore-header', 'value');
$http-&gt;remove_header('x-requestcore-header');

var_dump($http-&gt;request_headers);]]></code><result><![CDATA[array(2) {
  ["Expect"]=&gt;
  string(12) "100-continue"
  ["Connection"]=&gt;
  string(5) "close"
}]]></result></example></examples></method><method><name>send_multi_request</name><parameters><parameter><name>handles</name><required>true</required></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Sends the request using curl_multi_exec(), enabling parallel requests.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$handles]]></param><type><![CDATA[array]]></type><required><![CDATA[Required]]></required><description><![CDATA[An indexed array of cURL handles to process simultaneously.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[_array_ Post-processed cURL responses.]]></line></contents></section></docBlock><documented>true</documented><source><startLine>618</startLine><endLine>660</endLine><numberOfLines>43</numberOfLines><code><![CDATA[public function send_multi_request($handles)
{
    // Initialize MultiCURL
    $multi_handle = curl_multi_init();

    // Loop through each of the CURL handles and add them to the MultiCURL request.
    foreach ($handles as $handle)
    {
        curl_multi_add_handle($multi_handle, $handle);
    }

    $count = 0;

    // Execute
    do
    {
        $status = curl_multi_exec($multi_handle, $active);
    }
    while ($status == CURLM_CALL_MULTI_PERFORM || $active);

    // Define this.
    $handles_post = array();

    // Retrieve each handle response
    foreach ($handles as $handle)
    {
        if (curl_errno($handle) == CURLE_OK)
        {
            $http = new $this-&gt;request_class(null);
            $handles_post[] = $http-&gt;process_response($handle, curl_multi_getcontent($handle));
        }
        else
        {
            throw new RequestCore_Exception(curl_error($handle));
        }

        // Explicitly close each cURL handle.
        curl_multi_remove_handle($multi_handle, $handle);
        curl_close($handle);
    }

    return $handles_post;
}
]]></code></source><examples><example><title><![CDATA[Collect cURL handles for two requests, fire them, then display the response bodies.]]></title><code><![CDATA[$http = new RequestCore();

$responses = $http-&gt;send_multi_request(array(
	$http-&gt;set_request_url('http://github.com/skyzyx/requestcore/raw/master/_tests/test_request.txt')-&gt;prep_request(),
	$http-&gt;set_request_url('http://github.com/skyzyx/requestcore/raw/master/_tests/test_request2.txt')-&gt;prep_request()
));

$bodies = array(
	$responses[0]-&gt;body,
	$responses[1]-&gt;body,
);

var_dump($bodies);]]></code><result><![CDATA[array(2) {
  [0]=&gt;
  string(48) "abcdefghijklmnopqrstuvwxyz
0123456789
!@#$%^&amp;*()"
  [1]=&gt;
  string(48) ")(*&amp;^%$#@!
9876543210
zyxwvutsrqponmljkihgfedcba"
}]]></result></example></examples></method><method><name>send_request</name><parameters><parameter><name>parse</name><required>false</required><defaultValue><![CDATA[false]]></defaultValue></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Sends the request, calling necessary utility functions to update built-in properties.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$parse]]></param><type><![CDATA[boolean]]></type><required><![CDATA[Optional]]></required><description><![CDATA[Whether to parse the response with ResponseCore or not.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[_string_ The resulting unparsed data from the request.]]></line></contents></section></docBlock><documented>true</documented><source><startLine>589</startLine><endLine>603</endLine><numberOfLines>15</numberOfLines><code><![CDATA[public function send_request($parse = false)
{
    $curl_handle = $this-&gt;prep_request();
    $this-&gt;response = curl_exec($curl_handle);
    $parsed_response = $this-&gt;process_response($curl_handle, $this-&gt;response);

    curl_close($curl_handle);

    if ($parse)
    {
        return $parsed_response;
    }

    return $this-&gt;response;
}
]]></code></source><examples><example><title><![CDATA[Send the request, parse it with ResponseCore, and display only the body.]]></title><code><![CDATA[$http = new RequestCore('http://github.com/skyzyx/requestcore/raw/master/_tests/test_request.txt');
$response = $http-&gt;send_request(true);

var_dump($response-&gt;body);]]></code><result><![CDATA[string(48) "abcdefghijklmnopqrstuvwxyz
0123456789
!@#$%^&amp;*()"]]></result></example><example><title><![CDATA[Set the URL via set_request_url() instead of the constructor, send the request, parse it with ResponseCore, and display only the body.]]></title><code><![CDATA[$http = new RequestCore();

$http-&gt;set_request_url('http://github.com/skyzyx/requestcore/raw/master/_tests/test_request.txt');
$response = $http-&gt;send_request(true);

var_dump($response-&gt;body);]]></code><result><![CDATA[string(48) "abcdefghijklmnopqrstuvwxyz
0123456789
!@#$%^&amp;*()"]]></result></example><example><title><![CDATA[Send a HEAD request instead of a GET request, and display the response's Content-Type and non-body (since this is a HEAD request).]]></title><code><![CDATA[$http = new RequestCore('http://github.com/skyzyx/requestcore/raw/master/_tests/test_request.txt');
$http-&gt;set_method($http::HTTP_HEAD);
$response = $http-&gt;send_request(true);

var_dump($response-&gt;header['content-type']);
var_dump($response-&gt;body);]]></code><result><![CDATA[string(25) "text/plain; charset=utf-8"
bool(false)]]></result></example></examples></method><method><name>set_body</name><parameters><parameter><name>body</name><required>true</required></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Set the body to send in the request.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$body]]></param><type><![CDATA[string]]></type><required><![CDATA[Required]]></required><description><![CDATA[The textual content to send along in the body of the request.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[`$this`]]></line></contents></section></docBlock><documented>true</documented><source><startLine>333</startLine><endLine>337</endLine><numberOfLines>5</numberOfLines><code><![CDATA[public function set_body($body)
{
    $this-&gt;request_body = $body;
    return $this;
}
]]></code></source></method><method><name>set_credentials</name><parameters><parameter><name>user</name><required>true</required></parameter><parameter><name>pass</name><required>true</required></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Sets the credentials to use for authentication.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$user]]></param><type><![CDATA[string]]></type><required><![CDATA[Required]]></required><description><![CDATA[The username to authenticate with.]]></description></entry><entry><param><![CDATA[$pass]]></param><type><![CDATA[string]]></type><required><![CDATA[Required]]></required><description><![CDATA[The password to authenticate with.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[`$this`]]></line></contents></section></docBlock><documented>true</documented><source><startLine>233</startLine><endLine>238</endLine><numberOfLines>6</numberOfLines><code><![CDATA[public function set_credentials($user, $pass)
{
    $this-&gt;username = $user;
    $this-&gt;password = $pass;
    return $this;
}
]]></code></source><examples><example><title><![CDATA[Pass credentials to set_credentials(), and display the username to use.]]></title><code><![CDATA[$http = new RequestCore('http://github.com/skyzyx/requestcore/raw/master/_tests/test_request.txt');
$http-&gt;set_credentials('user', 'pass');
$http-&gt;prep_request();
var_dump($http-&gt;username);]]></code><result><![CDATA[string(4) "user"]]></result></example><example><title><![CDATA[Pass credentials to set_credentials(), and display the password to use.]]></title><code><![CDATA[$http = new RequestCore('http://github.com/skyzyx/requestcore/raw/master/_tests/test_request.txt');
$http-&gt;set_credentials('user', 'pass');
$http-&gt;prep_request();
var_dump($http-&gt;password);]]></code><result><![CDATA[string(4) "pass"]]></result></example></examples></method><method><name>set_curlopts</name><parameters><parameter><name>curlopts</name><required>true</required></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Set additional CURLOPT settings. These will merge with the default settings, and override if there is a duplicate.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$curlopts]]></param><type><![CDATA[array]]></type><required><![CDATA[Optional]]></required><description><![CDATA[A set of key-value pairs that set `CURLOPT` options. These will merge with the existing CURLOPTs, and ones passed here will override the defaults. Keys should be the `CURLOPT_` constants, not strings.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[`$this`]]></line></contents></section></docBlock><documented>true</documented><source><startLine>371</startLine><endLine>375</endLine><numberOfLines>5</numberOfLines><code><![CDATA[public function set_curlopts($curlopts)
{
    $this-&gt;curlopts = $curlopts;
    return $this;
}
]]></code></source></method><method><name>set_method</name><parameters><parameter><name>method</name><required>true</required></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Set the method type for the request.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$method]]></param><type><![CDATA[string]]></type><required><![CDATA[Required]]></required><description><![CDATA[One of the following constants: [HTTP_GET](../requestcore/constants.html#HTTP_GET), [HTTP_POST](../requestcore/constants.html#HTTP_POST), [HTTP_PUT](../requestcore/constants.html#HTTP_PUT), [HTTP_HEAD](../requestcore/constants.html#HTTP_HEAD), [HTTP_DELETE](../requestcore/constants.html#HTTP_DELETE).]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[`$this`]]></line></contents></section></docBlock><documented>true</documented><source><startLine>295</startLine><endLine>299</endLine><numberOfLines>5</numberOfLines><code><![CDATA[public function set_method($method)
{
    $this-&gt;method = strtoupper($method);
    return $this;
}
]]></code></source></method><method><name>set_proxy</name><parameters><parameter><name>proxy</name><required>true</required></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Set the proxy to use for making requests.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$proxy]]></param><type><![CDATA[string]]></type><required><![CDATA[Optional]]></required><description><![CDATA[The faux-url to use for proxy settings. Takes the following format: `proxy://user:pass@hostname:port`]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[`$this`]]></line></contents></section></docBlock><documented>true</documented><source><startLine>390</startLine><endLine>398</endLine><numberOfLines>9</numberOfLines><code><![CDATA[public function set_proxy($proxy)
{
    $proxy = parse_url($proxy);
    $proxy['user'] = isset($proxy['user']) ? $proxy['user'] : null;
    $proxy['pass'] = isset($proxy['pass']) ? $proxy['pass'] : null;
    $proxy['port'] = isset($proxy['port']) ? $proxy['port'] : null;
    $this-&gt;proxy = $proxy;
    return $this;
}
]]></code></source><examples><example><title><![CDATA[Pass in a proxy DSN string, and process it with prep_request() (without firing the request).]]></title><code><![CDATA[$http = new RequestCore('http://github.com/skyzyx/requestcore/raw/master/_tests/test_request.txt');
$http-&gt;set_proxy('proxy://user:pass@hostname:80');
$http-&gt;prep_request();

var_dump($http-&gt;proxy);]]></code><result><![CDATA[array(5) {
  ["scheme"]=&gt;
  string(5) "proxy"
  ["host"]=&gt;
  string(8) "hostname"
  ["port"]=&gt;
  int(80)
  ["user"]=&gt;
  string(4) "user"
  ["pass"]=&gt;
  string(4) "pass"
}]]></result></example></examples></method><method><name>set_request_url</name><parameters><parameter><name>url</name><required>true</required></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Set the URL to make the request to.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$url]]></param><type><![CDATA[string]]></type><required><![CDATA[Required]]></required><description><![CDATA[The URL to make the request to.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[`$this`]]></line></contents></section></docBlock><documented>true</documented><source><startLine>352</startLine><endLine>356</endLine><numberOfLines>5</numberOfLines><code><![CDATA[public function set_request_url($url)
{
    $this-&gt;request_url = $url;
    return $this;
}
]]></code></source><examples><example><title><![CDATA[Send a request and display the URL we requested.]]></title><code><![CDATA[$http = new RequestCore();
$http-&gt;set_request_url('http://github.com/skyzyx/requestcore/raw/master/_tests/test_request.txt');
$http-&gt;send_request();

var_dump($http-&gt;response_info['url']);]]></code><result><![CDATA[string(71) "http://github.com/skyzyx/requestcore/raw/master/_tests/test_request.txt"]]></result></example></examples></method><method><name>set_useragent</name><parameters><parameter><name>ua</name><required>true</required></parameter></parameters><access>public</access><docBlock><section><headline>Method</headline><contents><![CDATA[Sets a custom useragent string for the class.]]></contents></section><section><headline>Access</headline><contents><line><![CDATA[public]]></line></contents></section><section><headline>Parameters</headline><contents><entry><param><![CDATA[$ua]]></param><type><![CDATA[string]]></type><required><![CDATA[Required]]></required><description><![CDATA[The useragent string to use.]]></description></entry></contents></section><section><headline>Returns</headline><contents><line><![CDATA[`$this`]]></line></contents></section></docBlock><documented>true</documented><source><startLine>314</startLine><endLine>318</endLine><numberOfLines>5</numberOfLines><code><![CDATA[public function set_useragent($ua)
{
    $this-&gt;useragent = $ua;
    return $this;
}
]]></code></source><examples><example><title><![CDATA[Set a useragent string to use for HTTP requests.]]></title><code><![CDATA[$http = new RequestCore('http://github.com/skyzyx/requestcore/raw/master/_tests/test_request.txt');
$http-&gt;set_useragent('SampleUserAgentString');

var_dump($http-&gt;useragent);]]></code><result><![CDATA[string(21) "SampleUserAgentString"]]></result></example></examples></method></methods></class></vanity>
